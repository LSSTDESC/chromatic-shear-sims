#!/usr/bin/env python
"""
"""

import argparse
from datetime import datetime as dt
import functools
import itertools
import os
from pathlib import Path
import re
import time

import galsim
import joblib
import metadetect
import ngmix
import numpy as np
import pyarrow as pa
import pyarrow.compute as pc
import pyarrow.dataset as ds
import pyarrow.parquet as pq
from tqdm import tqdm, trange
import yaml

from chromatic_shear_bias import sed_tools, run_utils, lsst

from chromatic_shear_bias.generators import gals, stars


# GAL_COLORS = [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5]
# STAR_COLORS = [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5]
# GAL_COLORS = [0.5, 1.0, 1.5, 2.0, 2.5]
# STAR_COLORS = [0.5, 1.0, 1.5, 2.0, 2.5]
GAL_COLORS = [-0.6485919952392578, 0.2306804656982422, 0.9543704986572266, 1.5550565719604492, 3.4192733764648438]  # quartiles
STAR_COLORS = [-0.44138009999999994, 0.405656699999998, 0.5310984000000012, 0.8339373499999994, 2.6756930000000025]  # quartiles

SED_DIR = "/oak/stanford/orgs/kipac/users/smau/"


def compute_shear_pair(batch, calibration_shear):
    # g1p = np.array(data["p.g1"])
    # R11p = (np.array(data["p.g1p"]) - np.array(data["p.g1m"])) / (2 * calibration_shear)
    g1p = batch["p.g1"]
    R11p = pc.divide(pc.subtract(batch["p.g1p"], batch["p.g1m"]), 2 * calibration_shear)

    # g1m = np.array(data["m.g1"])
    # R11m = (np.array(data["m.g1p"]) - np.array(data["m.g1m"])) / (2 * calibration_shear)
    g1m = batch["m.g1"]
    R11m = pc.divide(pc.subtract(batch["m.g1p"], batch["m.g1m"]), 2 * calibration_shear)

    # g2p = np.array(data["p.g2"])
    # R22p = (np.array(data["p.g2p"]) - np.array(data["p.g2m"])) / (2 * calibration_shear)
    g2p = batch["p.g2"]
    R22p = pc.divide(pc.subtract(batch["p.g2p"], batch["p.g2m"]), 2 * calibration_shear)

    # g2m = np.array(data["m.g2"])
    # R22m = (np.array(data["m.g2p"]) - np.array(data["m.g2m"])) / (2 * calibration_shear)
    g2m = batch["m.g2"]
    R22m = pc.divide(pc.subtract(batch["m.g2p"], batch["m.g2m"]), 2 * calibration_shear)

    # weights = data["weight"]
    # if weights is not None:
    #     w = np.asarray(weights).astype(np.float64)
    # else:
    #     w = np.ones(len(g1p)).astype(np.float64)
    # w /= np.sum(w)

    # if ind is not None:
    #     g1p = g1p[ind]
    #     R11p = R11p[ind]
    #     g1m = g1m[ind]
    #     R11m = R11m[ind]
    #     g2p = g2p[ind]
    #     R22p = R22p[ind]
    #     g2m = g2m[ind]
    #     R22m = R22m[ind]
    #     w = w[ind]

    # msk = (
    #     np.isfinite(g1p) &
    #     np.isfinite(R11p) &
    #     np.isfinite(g1m) &
    #     np.isfinite(R11m) &
    #     np.isfinite(g2p) &
    #     np.isfinite(R22p) &
    #     np.isfinite(g2m) &
    #     np.isfinite(R22m)
    # )
    # g1p = g1p[msk]
    # R11p = R11p[msk]
    # g1m = g1m[msk]
    # R11m = R11m[msk]
    # g2p = g2p[msk]
    # R22p = R22p[msk]
    # g2m = g2m[msk]
    # R22m = R22m[msk]
    # w = w[msk]

    # return (np.nansum(g1p) - np.nansum(g1m)) / (np.nansum(R11p) + np.nansum(R11m))
    # return (
    #     pc.divide(pc.subtract(pc.sum(g1p), pc.sum(g1m)), pc.add(pc.sum(R11p), pc.sum(R11m)))
    # ).as_py() / 0.02 - 1.
    return g1p, g1m, R11p, R11m, g2p, g2m, R22p, R22m


def compute_m(arr):
    return (np.mean(arr[:, 0]) - np.mean(arr[:, 1])) / (np.mean(arr[:, 2]) + np.mean(arr[:, 3])) / 0.02 - 1.


def compute_c(arr):
    return (np.mean(arr[:, 4]) + np.mean(arr[:, 5])) / (np.mean(arr[:, 6]) + np.mean(arr[:, 7]))


def main():
    args = get_args()

    print(f"Using seed {args.seed}")

    with open(args.config, "r") as fp:
        config = yaml.safe_load(fp.read())

    rng = np.random.default_rng(args.seed)

    shear = 0.02


    print(f"gal colors: {GAL_COLORS}")
    print(f"star colors: {STAR_COLORS}")
    X, Y = np.meshgrid(STAR_COLORS, GAL_COLORS)
    m_est_grid = np.zeros((len(STAR_COLORS) - 1, len(GAL_COLORS) - 1))
    m_std_grid = np.zeros((len(STAR_COLORS) - 1, len(GAL_COLORS) - 1))

    with joblib.Parallel(n_jobs=args.n_jobs, verbose=10) as parallel:
        for j in range(len(STAR_COLORS) - 1):
            for i in range(len(GAL_COLORS) - 1):

                # dataset = ds.dataset(f"{args.output}/{i}-{j}.arrow", format="arrow")
                dataset = ds.dataset(f"{args.output}/{i}-{j}", format="arrow")

                predicate = \
                    pc.field("s2n_cut") == args.s2n_cut
                if args.ormask_cut is not None:
                    predicate &= (pc.field("ormask_cut") == args.ormask_cut)
                else:
                    predicate &= (pc.field("ormask_cut") == -1)
                if args.mfrac_cut is not None:
                    predicate &= (pc.field("mfrac_cut") == args.mfrac_cut)
                else:
                    predicate &= (pc.field("mfrac_cut") == -1)

                data = dataset.filter(predicate)

                m_req = 0.002
                calibration_shear = ngmix.metacal.DEFAULT_STEP
                cosmic_shear = shear


                seed = 10
                rng = np.random.RandomState(seed=seed)

                jobs = []
                for batch in data.to_batches():
                    jobs.append(
                        joblib.delayed(compute_shear_pair)(batch, calibration_shear)
                    )

                vals = parallel(jobs)

                vals = np.array(vals)

                resamples = []
                for _ in trange(args.n_resample, ncols=80):
                    rind = rng.choice(len(vals), size=len(vals), replace=True)
                    resamples.append(vals[rind])

                m_est = compute_m(vals)
                m_std = np.std(list(map(compute_m, resamples))) * 3

                c_est = compute_c(vals)
                c_std = np.std(list(map(compute_c, resamples))) * 3

                m_est_grid[i, j] = m_est
                m_std_grid[i, j] = m_std


    m_req = 2e-3
    vmax = np.nanmax(np.abs(m_est_grid)) / 1e-3
    vmin = -vmax

    import matplotlib.pyplot as plt
    from mpl_toolkits.axes_grid1 import make_axes_locatable

    fig, axs = plt.subplots(1, 2)

    # im = axs[0].imshow(m_est_grid / 1e-3, vmin=vmin, vmax=vmax, cmap="seismic")
    im = axs[0].pcolormesh(X, Y, m_est_grid / 1e-3, vmin=vmin, vmax=vmax, cmap="seismic")
    axs[0].set_xlim(-1, 4)
    axs[0].set_ylim(-1, 4)
    axs[0].set_aspect("equal")
    divider = make_axes_locatable(axs[0])
    cax = divider.append_axes('right', size='5%', pad=0.1)
    fig.colorbar(im, cax=cax)
    axs[0].set_xlabel(f"galactic $g - i$ (apparent, unlensed)")
    axs[0].set_ylabel(f"stellar $g - i$")
    axs[0].set_title("$m_{\mu} / 10^{-3}$")

    # im = axs[1].imshow(m_std_grid / 1e-3, vmin=vmin, vmax=vmax, cmap="seismic")
    im = axs[1].pcolormesh(X, Y, m_std_grid / 1e-3, vmin=vmin, vmax=vmax, cmap="seismic")
    axs[1].set_xlim(-1, 4)
    axs[1].set_ylim(-1, 4)
    axs[1].set_aspect("equal")
    divider = make_axes_locatable(axs[1])
    cax = divider.append_axes('right', size='5%', pad=0.1)
    fig.colorbar(im, cax=cax)
    axs[1].set_xlabel(f"galactic $g - i$ (apparent, unlensed)")
    axs[1].set_ylabel(f"stellar $g - i$")
    axs[1].set_title("$m_{\sigma} / 10^{-3}$")

    plt.suptitle("$r$ band")

    plt.savefig("grid.pdf")
    plt.show()

    print(f"Finished")


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--config",
        type=str,
        required=True,
        help="Metadetection configuration file [yaml]",
    )
    parser.add_argument(
        "--mag",
        type=float,
        required=False,
        default=None,
        help="r-band magnitude at which to draw galaxies",
    )
    parser.add_argument(
        "--n_coadd",
        type=int,
        required=False,
        default=100,
        help="Number of exposures in coadd [int]",
    )
    parser.add_argument(
        "--seed",
        type=int,
        required=False,
        default=None,
        help="RNG seed [int]",
    )
    parser.add_argument(
        "--n_sims",
        type=int,
        required=False,
        default=1,
        help="Number of sims to run [int]",
    )
    parser.add_argument(
        "--n_jobs",
        type=int,
        required=False,
        default=joblib.cpu_count(),
        # default=max(1, joblib.cpu_count() // 2),
        help="Number of jobs to run [int]",
    )
    parser.add_argument(
        "--output",
        type=str,
        required=False,
        default="",
        help="Output directory"
    )
    parser.add_argument(
        "--s2n-cut", type=int, default=10,
    )
    parser.add_argument(
        "--ormask-cut", type=int, default=None,
        help="Cut to make on ormask. 0 indicates make a cut, 1 indicates no cut.",
    )
    parser.add_argument(
        "--mfrac-cut", type=int, default=None,
        help="Cut to make on mfrac. Given in percentages and comma separated. Cut keeps all objects less than the given value.",
    )
    parser.add_argument("--n_resample", type=int, required=False, default=1000, help="Number of resample iterations")
    return parser.parse_args()


if __name__ == "__main__":
    main()
