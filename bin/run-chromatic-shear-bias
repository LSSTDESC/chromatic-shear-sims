#!/usr/bin/env python
"""
Staging file for generating simulations and running metadetect
"""

import argparse
import copy
import logging
import os
import shutil
from pathlib import Path

from mpi4py import MPI
import numpy as np
import pandas as pd
import pyarrow as pa
import pyarrow.dataset as ds
import pyarrow.parquet as pq
import yaml

import fitsio
import galsim
import ngmix
import metadetect

from chromatic_shear_bias import run_utils


comm = MPI.COMM_WORLD
rank = comm.Get_rank()
size = comm.Get_size()


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--config",
        type=str,
        required=True,
        help="Metadetection configuration file [yaml]",
    )
    parser.add_argument(
        "--sim",
        type=str,
        required=True,
        help="GalSim configuration file [yaml]",
    )
    parser.add_argument(
        "--seed",
        type=int,
        required=False,
        default=1,
        help="RNG seed [int]",
    )
    parser.add_argument(
        "--n_sims",
        type=int,
        required=False,
        default=1,
        help="Number of sims to run [int]",
    )
    parser.add_argument("--output", type=str, required=True, help="Output directory")
    return parser.parse_args()


def get_logger():
    """
    Format logger.
    """
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    ch = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    return logger


def main():
    """
    Run the simulation and measurement for metadetect noise bias cancellation.
    """
    args = get_args()
    logger = get_logger()

    # output file path
    root_path = Path(args.output)
    # if root_path.exists() and not root_path.is_dir():
    #     raise RuntimeError(f"{root_path} exists but is not a directory!")
    if not root_path.exists():
        root_path.mkdir(exist_ok=True)
    path_p = root_path / f"out_p-{rank}.parquet"
    path_m = root_path / f"out_m-{rank}.parquet"

    _config = None
    _galsim_config = None
    if rank == 0:
        logger.info(f"Running: {vars(args)}")
        logger.info(f"Running with {size} MPI processes")

        with open(args.config, "r") as fp:
            _config = yaml.safe_load(fp.read())

        galsim_configs = galsim.config.ReadConfig(args.sim)
        assert len(galsim_configs) == 1, f"Expected 1 GalSim config in {args.sim}; found {len(galsim_configs)}"
        _galsim_config = galsim_configs[0]

    # Broadcast configs from rank 0 process
    config = comm.bcast(_config, root=0)
    galsim_config = comm.bcast(_galsim_config, root=0)

    # TODO can this help reduce redundant IO?
    # # Load input objects in advance
    # all_keys = [str(k) for k in galsim_config['input'].keys() if k in galsim.config.input.valid_input_types]
    # _input_objs = {}
    # for key in all_keys:
    #     fields = galsim_config['input'][key]
    #     nfields = len(fields) if isinstance(fields, list) else 1
    #     _input_objs_key = []
    #     for num in range(nfields):
    #         _input_obj = galsim.config.input.LoadInputObj(
    #             galsim_config,
    #             key,
    #             num,
    #         )
    #         _input_objs_key.append(_input_obj)
    #     _input_objs[key] = _input_objs_key
    # # galsim.config.SetInConfig(_galsim_config, "_input_objs", _input_objs)


    # logger.info(f"Processing inputs in GalSim config")
    # galsim.config.ProcessInput(_galsim_config)  # TODO Is this the best place to call this?

    # Initialize the parquet writers for subsequent writes
    schema = pa.schema(run_utils._get_dtype())
    pqwriter_p = pq.ParquetWriter(path_p, schema)
    pqwriter_m = pq.ParquetWriter(path_m, schema)

    # Setup the seed for each rank
    seed = args.seed + rank

    for kwargs in run_utils.generate_arguments(
        config, galsim_config, seed, args.n_sims, logger,
    ):
        index = kwargs["index"]
        meas_p, meas_m = run_utils.make_and_measure_pairs(**kwargs)

        # TODO add column in dataset for shear; partition along this column?
        table_p = pa.Table.from_pandas(
            pd.DataFrame(np.array(meas_p, dtype=run_utils._get_dtype())),
            schema,
        )
        table_m = pa.Table.from_pandas(
            pd.DataFrame(np.array(meas_m, dtype=run_utils._get_dtype())),
            schema,
        )

        pqwriter_p.write_table(table_p)
        pqwriter_m.write_table(table_m)

        # Track progress over all ranks
        progress = comm.reduce(index)
        if (rank == 0) and (progress > 0) and (progress % 10 == 0):
            logger.info(f"Proccessed {progress} paired image simulations")

        # Periodically measure bias on rank 0
        # if (rank == 0) and (progress is not None) and (progress > 0) and (progress % 100 == 0):
        #     calibration_shear = ngmix.metacal.DEFAULT_STEP
        #     with fitsio.FITS(path, "r") as fits:
        #         pdata = fits["plus"].read()
        #         mdata = fits["minus"].read()
        #     pmsk = (pdata["s2n_cut"] == 10)
        #     pmsk &= (pdata["ormask_cut"] == -1)
        #     pmsk &= (pdata["mfrac_cut"] == 100)
        #     n_sims_msk = np.sum(pdata["weight"][pmsk])
        #     if n_sims_msk <= 0:
        #         logger.info(f"No sims pass measurement cuts")
        #     else:
        #         m_est, m_std, c_est, c_std = estimate_biases(
        #             pdata[pmsk], mdata[pmsk], calibration_shear, cosmic_shear,
        #             weights=pdata["weight"][pmsk],
        #             method="bootstrap",
        #             n_resample=100,
        #         )
        #         logger.info(f"multiplicative bias: {m_est:.3e} +/- {m_std*3:.3e} (3 sigma) [s2n_cut = 10, ormask_cut = -1, mfrac_cut = 100, n_sims = {n_sims_msk}]")
        #         logger.info(f"additive bias: {c_est:.3e} +/- {c_std*3:.3e} (3 sigma) [s2n_cut = 10, ormask_cut = -1, mfrac_cut = 100, n_sims = {n_sims_msk}]")


    # Close connection from writers to parquet files
    pqwriter_p.close()
    pqwriter_m.close()

    logger.info(f"MPI -- Finished rank {rank}")


if __name__ == "__main__":
    main()

