#!/usr/bin/env python
"""
Staging file for generating simulations and running metadetect
"""

import argparse
import copy
import logging
from pathlib import Path

import yaml
import numpy as np
import pyarrow as pa
import pyarrow.compute as pc
import pyarrow.dataset as ds
import pyarrow.parquet as pq

import galsim
import ngmix
import metadetect

from chromatic_shear_bias import run_utils


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--config",
        type=str,
        required=True,
        help="Metadetection configuration file [yaml]",
    )
    parser.add_argument(
        "--s2n-cut", type=int, default=10,
    )
    parser.add_argument(
        "--ormask-cut", type=int, default=None,
        help="Cut to make on ormask. 0 indicates make a cut, 1 indicates no cut.",
    )
    parser.add_argument(
        "--mfrac-cut", type=int, default=None,
        help="Cut to make on mfrac. Given in percentages and comma separated. Cut keeps all objects less than the given value.",
    )
    parser.add_argument("--output", type=str, required=True, help="Output directory")
    parser.add_argument("--method", type=str, required=False, default="bootstrap", help="Method for calculating variance [bootstrap, jackknife]")
    parser.add_argument("--n_resample", type=int, required=False, default=1000, help="Number of resample iterations")
    parser.add_argument(
        "--save",
        type=str,
        required=False,
        default=None,
        help="Output file [png, pdf]",
    )
    return parser.parse_args()


def get_logger():
    """
    Format logger.
    """
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    ch = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    return logger


def main():
    """
    Run the simulation and measurement for metadetect noise bias cancellation.
    """
    args = get_args()
    logger = get_logger()

    with open(args.config, "r") as fp:
        config = yaml.safe_load(fp.read())

    # copy the config for safekeeping
    _config = copy.deepcopy(config)

    if "colors" in config:
        bands = config["colors"]["bands"]

    logger.info(f"Measuring: {vars(args)}")

    predicate = \
        pc.field("s2n_cut") == args.s2n_cut
    if args.ormask_cut is not None:
        predicate &= (pc.field("ormask_cut") == args.ormask_cut)
    else:
        predicate &= (pc.field("ormask_cut") == -1)
    if args.mfrac_cut is not None:
        predicate &= (pc.field("mfrac_cut") == args.mfrac_cut)
    else:
        predicate &= (pc.field("mfrac_cut") == -1)

    m_mean_grid = []
    m_std_grid = []
    c_mean_grid = []
    c_std_grid = []

    stellar_bins = []
    galactic_bins = []

    logger.info(f"Reading output files")
    # with open(f"{args.output}/key.yaml", "r") as fp:
    #     key = yaml.safe_load(fp.read())
    keys = (Path(args.output) / "key").glob("*.yaml")
    # dataset = ds.dataset(args.output)
    # for path in dataset.files:
    # for k, v in key.items():
    for key in keys:
        with open(key, "r") as fp:
            metadata = yaml.safe_load(fp.read())

        _i = key.stem  # FIXME better way?
        data_path = (Path(args.output) / "dataset" / _i).with_suffix(".parquet")
        # data = ds.dataset(path)
        # metadata = key[path]
        # data = ds.dataset(k)
        # metadata = v
        data = ds.dataset(data_path)
        stellar_colors = metadata["stellar_colors"]
        galactic_colors = metadata["galactic_colors"]

        data_dict = data.to_table(filter=predicate).to_pydict()

        n_sims_msk = np.sum(data_dict["weight"])
        if n_sims_msk <= 0:
            raise RuntimeError("Cuts did not keep any sims!")
        else:
            logger.info(f"{n_sims_msk} sims pass cuts")

        logger.info(f"Measuring multiplicative and additive biases")
        m_req = 0.002
        calibration_shear = ngmix.metacal.DEFAULT_STEP
        cosmic_shear = config["shear"]["g"]
        m_est, m_std, c_est, c_std = run_utils.estimate_biases(
            data_dict, calibration_shear, cosmic_shear,
            weights=data_dict["weight"],
            method=args.method,
            n_resample=args.n_resample,
        )

        logger.info(f"stellar bin: {stellar_colors} -- galactic bin: {galactic_colors} -- multiplicative bias: {m_est:.3e} +/- {m_std*3:.3e} (3 sigma)")
        logger.info(f"stellar bin: {stellar_colors} -- galactic bin: {galactic_colors} -- additive bias: {c_est:.3e} +/- {c_std*3:.3e} (3 sigma)")
        logger.info(f"")

        m_mean_grid.append(m_est)
        m_std_grid.append(m_std)
        c_mean_grid.append(c_est)
        c_std_grid.append(c_std)

        stellar_bins.append(stellar_colors)
        galactic_bins.append(galactic_colors)

    # Sort by bins (first stellar, then galactic)
    ind = np.lexsort((galactic_bins, stellar_bins), axis=0)[:, 0]
    grid = np.meshgrid(np.unique(stellar_bins), np.unique(galactic_bins))  # FIXME generate grid from bins directly; don't remake and reassert bins
    shape = (grid[0].shape[0] - 1, grid[0].shape[1] - 1)  # FIXME
    m_mean_grid = np.array(m_mean_grid)[ind].ravel().reshape(shape)
    m_std_grid = np.array(m_std_grid)[ind].ravel().reshape(shape)
    c_mean_grid = np.array(c_mean_grid)[ind].ravel().reshape(shape)
    c_std_grid = np.array(c_std_grid)[ind].ravel().reshape(shape)

    m_req = 2e-3
    vmax = np.max(np.abs(m_mean_grid)) / 1e-3
    vmin = -vmax

    import matplotlib.pyplot as plt
    from mpl_toolkits.axes_grid1 import make_axes_locatable

    # plt.pcolormesh(*grid, np.abs(m_mean_grid) - m_req, cmap="seismic")
    # # plt.pcolormesh(*grid, m_mean_grid)
    # plt.xlabel("galactic $g - i$ (apparent, unlensed)")
    # plt.ylabel("stellar $g - i$")
    # # plt.colorbar(label="m")
    # plt.colorbar(label="|m| - 2e-3")
    # plt.title("$r$-band measurements")

    # fig, axs = plt.subplots(1, 2)

    # im = axs[0].pcolormesh(*grid, m_mean_grid / 1e-3, vmin=vmin, vmax=vmax, cmap="seismic")
    # axs[0].set_xlim(0, 3)
    # axs[0].set_ylim(0, 3)
    # axs[0].set_aspect("equal")
    # divider = make_axes_locatable(axs[0])
    # cax = divider.append_axes('right', size='5%', pad=0.1)
    # fig.colorbar(im, cax=cax)
    # axs[0].set_xlabel(f"galactic ${{{bands[0]}}} - {{{bands[1]}}}$ (apparent, unlensed)")
    # axs[0].set_ylabel(f"stellar ${{{bands[0]}}} - {{{bands[1]}}}$")
    # axs[0].set_title("$\mu_m / 10^{-3}$")

    # im = axs[1].pcolormesh(*grid, m_std_grid / 1e-3, cmap="gray_r", vmin=0, vmax=vmax)
    # axs[1].set_aspect("equal")
    # axs[1].set_xlim(0, 3)
    # axs[1].set_ylim(0, 3)
    # divider = make_axes_locatable(axs[1])
    # cax = divider.append_axes('right', size='5%', pad=0.1)
    # fig.colorbar(im, cax=cax)
    # axs[1].set_title("$\sigma_m / 10^{-3}$")

    # plt.suptitle("$r$ band")

    fig, ax = plt.subplots(1, 1)

    im = ax.pcolormesh(*grid, m_mean_grid / 1e-3, vmin=vmin, vmax=vmax, cmap="seismic")
    ax.set_xlim(0, 3)
    ax.set_ylim(0, 3)
    ax.set_aspect("equal")
    divider = make_axes_locatable(ax)
    cax = divider.append_axes('right', size='5%', pad=0.1)
    fig.colorbar(im, cax=cax, label="$m / 10^{-3}$")
    ax.set_xlabel(f"galactic ${{{bands[0]}}} - {{{bands[1]}}}$ (apparent, unlensed)")
    ax.set_ylabel(f"stellar ${{{bands[0]}}} - {{{bands[1]}}}$")
    ax.set_title("$r$ band")

    if args.output is None:
        plt.show()
    else:
        logger.info(f"Writing visualization to disk")
        plt.savefig(args.save)

    # fig, axs = plt.subplots(1, 2)

    # im = axs[0].pcolormesh(*grid, c_mean_grid)
    # divider = make_axes_locatable(axs[0])
    # cax = divider.append_axes('right', size='5%', pad=0.05)
    # fig.colorbar(im, cax=cax)
    # axs[0].set_xlabel("galactic $g - i$ (apparent, unlensed)")
    # axs[0].set_ylabel("stellar $g - i$")
    # axs[0].set_title("c mean")

    # im = axs[1].pcolormesh(*grid, c_std_grid*3)
    # divider = make_axes_locatable(axs[1])
    # cax = divider.append_axes('right', size='5%', pad=0.05)
    # fig.colorbar(im, cax=cax)
    # axs[1].set_title("c std * 3")

    # plt.suptitle("$r$-band measurements")

    # plt.show()


if __name__ == "__main__":
    main()
